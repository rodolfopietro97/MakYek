% Simple first level file 
% (Maximize the cell of eat on a movement with strong constraints)

% Facts generated by software:
% 	enemy(I,J).
% 	computer(P,I,J).
% 	free(I,J).

% Guess
move(P, I, J) | notMove(P, I, J) :- canMove(P, I, J).

% Can move in one of four possible directions
canMove(P, I, J) :- canMoveInDirection1(P, I, J).
canMove(P, I, J) :- canMoveInDirection2(P, I, J).
canMove(P, I, J) :- canMoveInDirection3(P, I, J).
canMove(P, I, J) :- canMoveInDirection4(P, I, J).

canMoveInDirection1(P, I, J) :- computer(P, I1 , J1), free(I,J), I1=I+2, J1=J.
canMoveInDirection2(P, I, J) :- computer(P, I1 , J1), free(I,J), I1=I-2, J1=J. 
canMoveInDirection3(P, I, J) :- computer(P, I1 , J1), free(I,J), I1=I, J1=J+2. 
canMoveInDirection4(P, I, J) :- computer(P, I1 , J1), free(I,J), I1=I, J1=J-2.
canMoveInDirection4(P, I, J) :- computer(P, I1 , J1), free(I,J), I1=I, J1=J-3.

% The number of eatable enemies
nearEatableEnemyes(N,P,I,J) :- canMoveInDirection1(P,I,J), #count{I,J1 :  enemy(I,J1), J1=J-1} = N.
nearEatableEnemyes(N,P,I,J) :- canMoveInDirection1(P,I,J), #count{I,J1 :  enemy(I,J1), J1=J+1} = N.
nearEatableEnemyes(N,P,I,J) :- canMoveInDirection3(P,I,J), #count{I,J1 :  enemy(I,J1), J1=J-1} = N.
nearEatableEnemyes(N,P,I,J) :- canMoveInDirection3(P,I,J), #count{I,J1 :  enemy(I,J1), J1=J+1} = N.
nearEatableEnemyes(N,P,I,J) :- canMoveInDirection2(P,I,J), #count{I1,J :  enemy(I1,J), I1=I-1} = N.
nearEatableEnemyes(N,P,I,J) :- canMoveInDirection2(P,I,J), #count{I1,J :  enemy(I1,J), I1=I+1} = N.
nearEatableEnemyes(N,P,I,J) :- canMoveInDirection4(P,I,J), #count{I1,J :  enemy(I1,J), I1=I-1} = N.
nearEatableEnemyes(N,P,I,J) :- canMoveInDirection4(P,I,J), #count{I1,J :  enemy(I1,J), I1=I+1} = N.

% Mazimize near eatale enemies
:~ notMove(P,I,J), nearEatableEnemyes(N,P,I,J). [N@1,I,J]

% Strong constraints (eat all possible in a movement)
% direction 4
:- canMoveInDirection4(P,I,J), enemy(I,J1), enemy(I,J2), J1=J-1, J2=J-2, not move(P,I,J).
:- canMoveInDirection4(P,I,J), enemy(I2,J1), enemy(I2,J2), J1=J-1, J2=J-2, not move(P,I,J), I2=I+1.
:- canMoveInDirection4(P,I,J), enemy(I2,J1), enemy(I2,J2), J1=J-1, J2=J-2, not move(P,I,J), I2=I-1.
% direction 2
:- canMoveInDirection2(P,I,J), enemy(I,J1), J1=J+1, not move(P,I,J).
:- canMoveInDirection2(P,I,J), enemy(I2,J1), enemy(I2,J2), J1=J+1, J2=J+2, not move(P,I,J), I2=I+1.
:- canMoveInDirection2(P,I,J), enemy(I2,J1), enemy(I2,J2), J1=J+1, J2=J+2, not move(P,I,J), I2=I-1.
% direction 1
:- canMoveInDirection1(P,I,J), enemy(I1,J), I1=I+1, not move(P,I,J).
:- canMoveInDirection1(P,I,J), enemy(I2,J1), enemy(I2,J2), I1=I+1, I2=I+2, not move(P,I,J), J2=J+1.
:- canMoveInDirection1(P,I,J), enemy(I2,J1), enemy(I2,J2), I1=I+1, I2=I+2, not move(P,I,J), J2=J-1.
% direction 3
:- canMoveInDirection1(P,I,J), enemy(I1,J), I1=I-1, not move(P,I,J).
:- canMoveInDirection1(P,I,J), enemy(I2,J1), enemy(I2,J2), I1=I-1, I2=I-2, not move(P,I,J), J2=J+1.
:- canMoveInDirection1(P,I,J), enemy(I2,J1), enemy(I2,J2), I1=I-1, I2=I-2, not move(P,I,J), J2=J-1.

