free(0,0).free(0,1).free(0,2).free(0,3).free(0,4).enemy(0,5).computer(6,0,6).computer(5,0,7).free(1,0).free(1,1).free(1,2).free(1,3).free(1,4).enemy(1,5).computer(12,1,6).enemy(1,7).free(2,0).free(2,1).free(2,2).free(2,3).free(2,4).computer(21,2,5).computer(2,2,6).enemy(2,7).free(3,0).free(3,1).free(3,2).free(3,3).free(3,4).computer(29,3,5).computer(14,3,6).computer(41,3,7).free(4,0).free(4,1).free(4,2).free(4,3).computer(52,4,4).computer(37,4,5).computer(22,4,6).computer(39,4,7).free(5,0).free(5,1).free(5,2).computer(59,5,3).computer(28,5,4).computer(44,5,5).computer(46,5,6).computer(45,5,7).free(6,0).free(6,1).enemy(6,2).computer(51,6,3).computer(54,6,4).computer(23,6,5).computer(38,6,6).enemy(6,7).enemy(7,0).free(7,1).enemy(7,2).free(7,3).free(7,4).computer(61,7,5).enemy(7,6).enemy(7,7).
% Simple first level file 
% (Maximize the cell of eat on a movement with strong constraints)

% Facts generated by software:
% 	enemy(I,J).
% 	computer(P,I,J).
% 	free(I,J).

% Guess
move(P, I, J) | notMove(P, I, J) :- canMove(P, I, J).

% Can move in one of four possible directions
canMove(P, I, J) :- canMoveInDirection1(P, I, J).
canMove(P, I, J) :- canMoveInDirection2(P, I, J).
canMove(P, I, J) :- canMoveInDirection3(P, I, J).
canMove(P, I, J) :- canMoveInDirection4(P, I, J).

canMoveInDirection1(P, I, J) :- computer(P, I1 , J1), free(I,J), I1=I+2, J1=J.
canMoveInDirection2(P, I, J) :- computer(P, I1 , J1), free(I,J), I1=I-2, J1=J. 
canMoveInDirection3(P, I, J) :- computer(P, I1 , J1), free(I,J), I1=I, J1=J+2. 
canMoveInDirection4(P, I, J) :- computer(P, I1 , J1), free(I,J), I1=I, J1=J-2.
canMoveInDirection4(P, I, J) :- computer(P, I1 , J1), free(I,J), I1=I, J1=J-3.

% The number of eatable enemies
nearEatableEnemyes(N,P,I,J) :- canMoveInDirection1(P,I,J), #count{I,J1 :  enemy(I,J1), J1=J-1} = N.
nearEatableEnemyes(N,P,I,J) :- canMoveInDirection1(P,I,J), #count{I,J1 :  enemy(I,J1), J1=J+1} = N.
nearEatableEnemyes(N,P,I,J) :- canMoveInDirection3(P,I,J), #count{I,J1 :  enemy(I,J1), J1=J-1} = N.
nearEatableEnemyes(N,P,I,J) :- canMoveInDirection3(P,I,J), #count{I,J1 :  enemy(I,J1), J1=J+1} = N.
nearEatableEnemyes(N,P,I,J) :- canMoveInDirection2(P,I,J), #count{I1,J :  enemy(I1,J), I1=I-1} = N.
nearEatableEnemyes(N,P,I,J) :- canMoveInDirection2(P,I,J), #count{I1,J :  enemy(I1,J), I1=I+1} = N.
nearEatableEnemyes(N,P,I,J) :- canMoveInDirection4(P,I,J), #count{I1,J :  enemy(I1,J), I1=I-1} = N.
nearEatableEnemyes(N,P,I,J) :- canMoveInDirection4(P,I,J), #count{I1,J :  enemy(I1,J), I1=I+1} = N.

% Mazimize near eatale enemies
:~ notMove(P,I,J), nearEatableEnemyes(N,P,I,J). [N@1,I,J]

% Strong constraints (eat all possible in a movement)
% direction 4
:- canMoveInDirection4(P,I,J), enemy(I,J1), enemy(I,J2), J1=J-1, J2=J-2, not move(P,I,J).
:- canMoveInDirection4(P,I,J), enemy(I2,J1), enemy(I2,J2), J1=J-1, J2=J-2, not move(P,I,J), I2=I+1.
:- canMoveInDirection4(P,I,J), enemy(I2,J1), enemy(I2,J2), J1=J-1, J2=J-2, not move(P,I,J), I2=I-1.
% direction 2
:- canMoveInDirection2(P,I,J), enemy(I,J1), J1=J+1, not move(P,I,J).
:- canMoveInDirection2(P,I,J), enemy(I2,J1), enemy(I2,J2), J1=J+1, J2=J+2, not move(P,I,J), I2=I+1.
:- canMoveInDirection2(P,I,J), enemy(I2,J1), enemy(I2,J2), J1=J+1, J2=J+2, not move(P,I,J), I2=I-1.
% direction 1
:- canMoveInDirection1(P,I,J), enemy(I1,J), I1=I+1, not move(P,I,J).
:- canMoveInDirection1(P,I,J), enemy(I2,J1), enemy(I2,J2), I1=I+1, I2=I+2, not move(P,I,J), J2=J+1.
:- canMoveInDirection1(P,I,J), enemy(I2,J1), enemy(I2,J2), I1=I+1, I2=I+2, not move(P,I,J), J2=J-1.
% direction 3
:- canMoveInDirection1(P,I,J), enemy(I1,J), I1=I-1, not move(P,I,J).
:- canMoveInDirection1(P,I,J), enemy(I2,J1), enemy(I2,J2), I1=I-1, I2=I-2, not move(P,I,J), J2=J+1.
:- canMoveInDirection1(P,I,J), enemy(I2,J1), enemy(I2,J2), I1=I-1, I2=I-2, not move(P,I,J), J2=J-1.

